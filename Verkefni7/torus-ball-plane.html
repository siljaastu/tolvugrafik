<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Torus, kúla og gólf</title>
  </head>
  <body>
    <canvas id="c" width="800" height="800"></canvas>
    <script src="https://hjalmtyr.github.io/forrit25/ThreeJS/js/three.js"></script>
    <script src="https://hjalmtyr.github.io/forrit25/ThreeJS/js/examples/js/controls/OrbitControls.js"></script>
    <script>
      // Ná í striga
      const canvas = document.querySelector("#c");

      // Skilgreina sviðsnet
      const scene = new THREE.Scene();
      scene.background = new THREE.Color("skyblue");

      // Skilgreina myndavél og staðsetja hana
      const camera = new THREE.PerspectiveCamera(
        75,
        canvas.clientWidth / canvas.clientHeight,
        0.1,
        1000
      );
      camera.position.set(10, 2.5, 0);

      // Skilgreina birtingaraðferð með afbjögun (antialias)
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });

      // // Búa til tening með Phong áferð (Phong material) og bæta í sviðsnetið
      // const geometry = new THREE.BoxGeometry();
      // const material = new THREE.MeshPhongMaterial( { color: 0x44aa88 } );
      // const cube = new THREE.Mesh( geometry, material );
      // cube.position.x += 1;
      // scene.add( cube );

      // torus / kleinuhringur
      const torusRadius = 2.5; // major radius, frá miðju og að miðju túbunnar
      const torusTube = 0.8; // radius túbunnar
      const torusGeo = new THREE.TorusGeometry(torusRadius, torusTube, 32, 128);
      const torusMat = new THREE.MeshStandardMaterial({
        color: 0x2747d0,
        roughness: 0.6,
        metalness: 0.2,
      });
      const torus = new THREE.Mesh(torusGeo, torusMat);
      torus.position.set(0, torusRadius + torusTube, 2.5); //færum til hliðar til að hitta kúlu í gegn
      torus.rotation.y = Math.PI / 2;
      torus.castShadow = true;
      torus.receiveShadow = true;
      scene.add(torus);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.copy(torus.position);
      camera.lookAt(torus.position);
      controls.update();

      // Búa til kúlu með Phong áferð og bæta í sviðsnetið
      //   const ballGeometry = new THREE.SphereGeometry(0.5, 20, 20);
      //   const ballMaterial = new THREE.MeshPhongMaterial({ color: 0xaa8844 });
      //   const ball = new THREE.Mesh(ballGeometry, ballMaterial);
      //   ball.position.x += -1;
      //   scene.add(ball);

      const ballRadius = 0.7;
      const ballGeo = new THREE.SphereGeometry(ballRadius, 32, 32);
      const ballMat = new THREE.MeshStandardMaterial({
        color: 0xd32f2f,
        roughness: 0.4,
        metalness: 0.05,
      });
      const ball = new THREE.Mesh(ballGeo, ballMat);
      ball.castShadow = true;
      ball.receiveShadow = false;
      scene.add(ball);
      ball.position.set(0, torus.position.y, torusRadius - 0.05);

      // Búa til sléttu með Phong áferð
      const planeGeometry = new THREE.PlaneGeometry(40, 40);
      const planeMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });
      const plane = new THREE.Mesh(planeGeometry, planeMaterial);
      plane.rotation.x = -0.5 * Math.PI;
      plane.position.set(0, 0, 0);
      scene.add(plane);

      // Skilgreina ljósgjafa og bæta honum í sviðsnetið
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(2, 4, 1);
      scene.add(light);

      //orbit params
      const orbit = {
        speed: 3.5,
        radius: torusRadius - 0.05,
        height: torus.position.y,
      };

      const clock = new THREE.Clock();

      // Movement funct
      function updateBall(t) {
        const ang = t * orbit.speed;
        // Path lies in XZ plane
        const x = Math.cos(ang) * orbit.radius;
        const z = Math.sin(ang) * orbit.radius;
        const y = orbit.height + 0.04 * Math.sin(ang * 2.5);
        ball.position.set(x, y, z);
      }

      window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });

      // animation loop
      function animate() {
        requestAnimationFrame(animate);
        const t = clock.getElapsedTime();
        updateBall(t);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
    </script>
  </body>
</html>
